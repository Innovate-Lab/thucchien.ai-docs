---
sidebar_position: 5
---

# Sinh video v·ªõi Veo 3 (Quy tr√¨nh b·∫•t ƒë·ªìng b·ªô)

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

Vi·ªác t·∫°o video l√† m·ªôt t√°c v·ª• t·ªën nhi·ªÅu t√†i nguy√™n v√† th·ªùi gian. Do ƒë√≥, t∆∞∆°ng t√°c v·ªõi m√¥ h√¨nh `veo 3` kh√¥ng di·ªÖn ra ngay l·∫≠p t·ª©c m√† theo m·ªôt quy tr√¨nh b·∫•t ƒë·ªìng b·ªô (asynchronous) g·ªìm 3 b∆∞·ªõc.

**Model ƒë∆∞·ª£c h·ªó tr·ª£:** `veo 3` (Google Vertex AI)

## T·ªïng quan quy tr√¨nh

1.  **B·∫Øt ƒë·∫ßu t√°c v·ª•:** B·∫°n g·ª≠i m·ªôt y√™u c·∫ßu ch·ª©a m√¥ t·∫£ (prompt) ƒë·ªÉ b·∫Øt ƒë·∫ßu qu√° tr√¨nh t·∫°o video. API s·∫Ω tr·∫£ v·ªÅ m·ªôt `operation_name` ƒë·ªÉ b·∫°n theo d√µi.
2.  **Ki·ªÉm tra tr·∫°ng th√°i:** B·∫°n s·ª≠ d·ª•ng `operation_name` ƒë·ªÉ h·ªèi API xem video ƒë√£ ƒë∆∞·ª£c t·∫°o xong ch∆∞a. B·∫°n c·∫ßn l·∫∑p l·∫°i b∆∞·ªõc n√†y cho ƒë·∫øn khi nh·∫≠n ƒë∆∞·ª£c tr·∫°ng th√°i ho√†n t·∫•t.
3.  **T·∫£i video:** Khi video ƒë√£ s·∫µn s√†ng, k·∫øt qu·∫£ ki·ªÉm tra tr·∫°ng th√°i s·∫Ω ch·ª©a m·ªôt URI (ƒë∆∞·ªùng d·∫´n) ƒë·∫øn file video. B·∫°n s·ª≠ d·ª•ng URI n√†y ƒë·ªÉ t·∫£i video v·ªÅ.

## H∆∞·ªõng d·∫´n chi ti·∫øt

<Tabs>
  <TabItem value="curl" label="curl (T·ª´ng b∆∞·ªõc)">
    <h4>B∆∞·ªõc 1: B·∫Øt ƒë·∫ßu t·∫°o video</h4>
    <p>G·ª≠i m·ªôt y√™u c·∫ßu POST ƒë·∫øn endpoint ƒë·∫∑c bi·ªát d√†nh cho Veo.</p>
    :::info[Quan tr·ªçng]
    Do m√°y ch·ªß proxy ƒëang s·ª≠ d·ª•ng c∆° ch·∫ø pass-through t·ªõi Google AI Studio, b·∫°n s·∫Ω s·ª≠ d·ª•ng header `x-goog-api-key` thay cho header `Authorization` ti√™u chu·∫©n.
    :::
    <CodeBlock language="bash">
    {`curl -X POST https://api0.lab.vbi-server.com/gemini/v1beta/models/veo-3.0-generate-preview:predictLongRunning \\
  -H "Content-Type: application/json" \\
  -H "x-goog-api-key: <your_api_key>" \\
  -d '{
    "instances": [{
      "prompt": "A cinematic shot of a hummingbird flying in slow motion"
    }]
  }'`}
    </CodeBlock>
    <p>N·∫øu th√†nh c√¥ng, API s·∫Ω tr·∫£ v·ªÅ m·ªôt JSON ch·ª©a <code>name</code> c·ªßa t√°c v·ª•. H√£y l∆∞u l·∫°i gi√° tr·ªã n√†y.</p>
    <CodeBlock language="json">
    {`{
  "name": "models/veo-3.0-generate-preview/operations/idrk08ltkg0a"
}`}
    </CodeBlock>
    
    <h4>B∆∞·ªõc 2: Ki·ªÉm tra tr·∫°ng th√°i</h4>
    <p>S·ª≠ d·ª•ng <code>operation_name</code> b·∫°n nh·∫≠n ƒë∆∞·ª£c ·ªü B∆∞·ªõc 1 ƒë·ªÉ g·ª≠i y√™u c·∫ßu GET.</p>
    <CodeBlock language="bash">
    {`# Thay operations/idrk08ltkg0a b·∫±ng operation_name c·ªßa b·∫°n
curl https://api0.lab.vbi-server.com/gemini/v1beta/models/veo-3.0-generate-preview/operations/idrk08ltkg0a \\
  -H "x-goog-api-key: <your_api_key>"`}
    </CodeBlock>
    <p>L·∫∑p l·∫°i y√™u c·∫ßu n√†y cho ƒë·∫øn khi response ch·ª©a <code>"done": true</code>.</p>
    <CodeBlock language="json">
    {`{
    "name": "models/veo-3.0-generate-preview/operations/idrk08ltkg0a",
    "done": true,
    "response": {
        "@type": "type.googleapis.com/google.ai.generativelanguage.v1beta.PredictLongRunningResponse",
        "generateVideoResponse": {
            "generatedSamples": [
                {
                    "video": {
                        "uri": "https://generativelanguage.googleapis.com/v1beta/files/3j6svp4106e7:download?alt=media"
                    }
                }
            ]
        }
    }
}`}
    </CodeBlock>

    <h4>B∆∞·ªõc 3: T·∫£i video</h4>
    <p>S·ª≠ d·ª•ng <code>uri</code> t·ª´ response ·ªü B∆∞·ªõc 2 ƒë·ªÉ t·∫£i video.</p>
    <CodeBlock language="bash">
    {`# URI g·ªëc: https://generativelanguage.googleapis.com/v1beta/files/3j6svp4106e7:download?alt=media
# File path: v1beta/files/3j6svp4106e7:download?alt=media

curl https://api0.lab.vbi-server.com/gemini/download/v1beta/files/3j6svp4106e7:download?alt=media \\
  -H "x-goog-api-key: <your_api_key>" \\
  --output my_generated_video.mp4`}
    </CodeBlock>
    <p>K·∫øt qu·∫£ b·∫°n s·∫Ω c√≥ file video nh∆∞ sau:</p>
    <video controls style={{maxWidth: '100%'}}>
        <source src="/video/my_generated_video.mp4" type="video/mp4" />
    </video>
  </TabItem>
  <TabItem value="python" label="Python (Script t·ª± ƒë·ªông)">
    <p>D∆∞·ªõi ƒë√¢y l√† m·ªôt k·ªãch b·∫£n Python ho√†n ch·ªânh ƒë·ªÉ t·ª± ƒë·ªông h√≥a c·∫£ 3 b∆∞·ªõc.</p>
    :::info[Quan tr·ªçng]
    T∆∞∆°ng t·ª± nh∆∞ v√≠ d·ª• v·ªõi `curl`, k·ªãch b·∫£n Python n√†y c≈©ng s·ª≠ d·ª•ng header `x-goog-api-key` do c∆° ch·∫ø pass-through c·ªßa m√°y ch·ªß proxy.
    :::
    <CodeBlock language="python">
    {`#!/usr/bin/env python3
"""
Complete example for Veo video generation through LiteLLM proxy.

This script demonstrates how to:
1. Generate videos using Google's Veo model
2. Poll for completion status
3. Download the generated video file

Requirements:
- LiteLLM proxy running with Google AI Studio pass-through configured
- Google AI Studio API key with Veo access

# This file is forked and adapted from: https://github.com/BerriAI/litellm/blob/main/docs/my-website/docs/proxy/veo_video_generation.md .Please refer to the original for license details.
"""

import json
import os
import time
import requests
from typing import Optional


class VeoVideoGenerator:
    """Complete Veo video generation client using LiteLLM proxy."""
    
    def __init__(self, base_url: str = "https://api0.lab.vbi-server.com/gemini/v1beta", 
                 api_key: str = "sk-1234"):
        """
        Initialize the Veo video generator.
        
        Args:
            base_url: Base URL for the LiteLLM proxy with Gemini pass-through
            api_key: API key for LiteLLM proxy authentication
        """
        self.base_url = base_url
        self.api_key = api_key
        self.headers = {
            "x-goog-api-key": api_key,
            "Content-Type": "application/json"
        }
    
    def generate_video(self, prompt: str) -> Optional[str]:
        """
        Initiate video generation with Veo.
        
        Args:
            prompt: Text description of the video to generate
            
        Returns:
            Operation name if successful, None otherwise
        """
        print(f"üé¨ Generating video with prompt: '{prompt}'")
        
        url = f"{self.base_url}/models/veo-3.0-generate-preview:predictLongRunning"
        payload = {
            "instances": [{
                "prompt": prompt
            }]
        }
        
        try:
            response = requests.post(url, headers=self.headers, json=payload)
            response.raise_for_status()
            
            data = response.json()
            operation_name = data.get("name")
            
            if operation_name:
                print(f"‚úÖ Video generation started: {operation_name}")
                return operation_name
            else:
                print("‚ùå No operation name returned")
                print(f"Response: {json.dumps(data, indent=2)}")
                return None
                
        except requests.RequestException as e:
            print(f"‚ùå Failed to start video generation: {e}")
            if hasattr(e, 'response') and e.response is not None:
                try:
                    error_data = e.response.json()
                    print(f"Error details: {json.dumps(error_data, indent=2)}")
                except:
                    print(f"Error response: {e.response.text}")
            return None
    
    def wait_for_completion(self, operation_name: str, max_wait_time: int = 600) -> Optional[str]:
        """
        Poll operation status until video generation is complete.
        
        Args:
            operation_name: Name of the operation to monitor
            max_wait_time: Maximum time to wait in seconds (default: 10 minutes)
            
        Returns:
            Video URI if successful, None otherwise
        """
        print("‚è≥ Waiting for video generation to complete...")
        
        operation_url = f"{self.base_url}/{operation_name}"
        start_time = time.time()
        poll_interval = 10  # Start with 10 seconds
        
        while time.time() - start_time < max_wait_time:
            try:
                print(f"üîç Polling status... ({int(time.time() - start_time)}s elapsed)")
                
                response = requests.get(operation_url, headers=self.headers)
                response.raise_for_status()
                
                data = response.json()
                
                # Check for errors
                if "error" in data:
                    print("‚ùå Error in video generation:")
                    print(json.dumps(data["error"], indent=2))
                    return None
                
                # Check if operation is complete
                is_done = data.get("done", False)
                
                if is_done:
                    print("üéâ Video generation complete!")
                    
                    try:
                        # Extract video URI from nested response
                        video_uri = data["response"]["generateVideoResponse"]["generatedSamples"][0]["video"]["uri"]
                        print(f"üìπ Video URI: {video_uri}")
                        return video_uri
                    except KeyError as e:
                        print(f"‚ùå Could not extract video URI: {e}")
                        print("Full response:")
                        print(json.dumps(data, indent=2))
                        return None
                
                # Wait before next poll, with exponential backoff
                time.sleep(poll_interval)
                poll_interval = min(poll_interval * 1.2, 30)  # Cap at 30 seconds
                
            except requests.RequestException as e:
                print(f"‚ùå Error polling operation status: {e}")
                time.sleep(poll_interval)
        
        print(f"‚è∞ Timeout after {max_wait_time} seconds")
        return None
    
    def download_video(self, video_uri: str, output_filename: str = "generated_video.mp4") -> bool:
        """
        Download the generated video file.
        
        Args:
            video_uri: URI of the video to download (from Google's response)
            output_filename: Local filename to save the video
            
        Returns:
            True if download successful, False otherwise
        """
        print(f"‚¨áÔ∏è  Downloading video...")
        print(f"Original URI: {video_uri}")
        
        # Convert Google URI to LiteLLM proxy URI
        # Example: https://generativelanguage.googleapis.com/v1beta/files/abc123 -> /gemini/download/v1beta/files/abc123:download?alt=media
        if video_uri.startswith("https://generativelanguage.googleapis.com/"):
            relative_path = video_uri.replace(
                "https://generativelanguage.googleapis.com/",
                ""
            )
        else:
            relative_path = video_uri

        # base_url: https://api0.lab.vbi-server.com/gemini/v1beta
        if self.base_url.endswith("/v1beta"):
            base_path = self.base_url.replace("/v1beta", "/download")
        else:
            base_path = self.base_url

        litellm_download_url = f"{base_path}/{relative_path}"
        print(f"Download URL: {litellm_download_url}")
        
        try:
            # Download with streaming and redirect handling
            response = requests.get(
                litellm_download_url, 
                headers=self.headers, 
                stream=True,
                allow_redirects=True  # Handle redirects automatically
            )
            response.raise_for_status()
            
            # Save video file
            with open(output_filename, 'wb') as f:
                downloaded_size = 0
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
                        downloaded_size += len(chunk)
                        
                        # Progress indicator for large files
                        if downloaded_size % (1024 * 1024) == 0:  # Every MB
                            print(f"üì¶ Downloaded {downloaded_size / (1024*1024):.1f} MB...")
            
            # Verify file was created and has content
            if os.path.exists(output_filename):
                file_size = os.path.getsize(output_filename)
                if file_size > 0:
                    print(f"‚úÖ Video downloaded successfully!")
                    print(f"üìÅ Saved as: {output_filename}")
                    print(f"üìè File size: {file_size / (1024*1024):.2f} MB")
                    return True
                else:
                    print("‚ùå Downloaded file is empty")
                    os.remove(output_filename)
                    return False
            else:
                print("‚ùå File was not created")
                return False
                
        except requests.RequestException as e:
            print(f"‚ùå Download failed: {e}")
            if hasattr(e, 'response') and e.response is not None:
                print(f"Status code: {e.response.status_code}")
                print(f"Response headers: {dict(e.response.headers)}")
            return False
    
    def generate_and_download(self, prompt: str, output_filename: str = None) -> bool:
        """
        Complete workflow: generate video and download it.
        
        Args:
            prompt: Text description for video generation
            output_filename: Output filename (auto-generated if None)
            
        Returns:
            True if successful, False otherwise
        """
        # Auto-generate filename if not provided
        if output_filename is None:
            timestamp = int(time.time())
            safe_prompt = "".join(c for c in prompt[:30] if c.isalnum() or c in (' ', '-', '_')).rstrip()
            output_filename = f"veo_video_{safe_prompt.replace(' ', '_')}_{timestamp}.mp4"
        
        print("=" * 60)
        print("üé¨ VEO VIDEO GENERATION WORKFLOW")
        print("=" * 60)
        
        # Step 1: Generate video
        operation_name = self.generate_video(prompt)
        if not operation_name:
            return False
        
        # Step 2: Wait for completion
        video_uri = self.wait_for_completion(operation_name)
        if not video_uri:
            return False
        
        # Step 3: Download video
        success = self.download_video(video_uri, output_filename)
        
        if success:
            print("=" * 60)
            print("üéâ SUCCESS! Video generation complete!")
            print(f"üìÅ Video saved as: {output_filename}")
            print("=" * 60)
        else:
            print("=" * 60)
            print("‚ùå FAILED! Video generation or download failed")
            print("=" * 60)
        
        return success


def main():
    """
    Example usage of the VeoVideoGenerator.
    
    Configure these environment variables:
    - LITELLM_BASE_URL: Your LiteLLM proxy URL (default: https://api0.lab.vbi-server.com/gemini/v1beta)
    - LITELLM_API_KEY: Your LiteLLM API key (default: sk-1234)
    """
    
    # Configuration from environment or defaults
    base_url = os.getenv("LITELLM_BASE_URL", "https://api0.lab.vbi-server.com/gemini/v1beta")
    api_key = os.getenv("LITELLM_API_KEY", "sk-1234")
    
    print("üöÄ Starting Veo Video Generation Example")
    print(f"üì° Using LiteLLM proxy at: {base_url}")
    
    # Initialize generator
    generator = VeoVideoGenerator(base_url=base_url, api_key=api_key)
    
    # Example prompts - try different ones!
    example_prompts = [
        "A cat playing with a ball of yarn in a sunny garden",
        "Ocean waves crashing against rocky cliffs at sunset",
        "A bustling city street with people walking and cars passing by",
        "A peaceful forest with sunlight filtering through the trees"
    ]
    
    # Use first example or get from user
    prompt = example_prompts[0]
    print(f"üé¨ Using prompt: '{prompt}'")
    
    # Generate and download video
    success = generator.generate_and_download(prompt)
    
    if success:
        print("\n‚úÖ Example completed successfully!")
        print("üí° Try modifying the prompt in the script for different videos!")
    else:
        print("\n‚ùå Example failed!")
        print("üîß Check your API Configuration")

if __name__ == "__main__":
    main()`}
    </CodeBlock>
  </TabItem>
</Tabs>
