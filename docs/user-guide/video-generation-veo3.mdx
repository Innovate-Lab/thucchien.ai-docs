---
sidebar_position: 5
---

# Sinh video v·ªõi Veo 3 (Quy tr√¨nh b·∫•t ƒë·ªìng b·ªô)

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

Vi·ªác t·∫°o video l√† m·ªôt t√°c v·ª• t·ªën nhi·ªÅu t√†i nguy√™n v√† th·ªùi gian. Do ƒë√≥, t∆∞∆°ng t√°c v·ªõi m√¥ h√¨nh `veo 3` kh√¥ng di·ªÖn ra ngay l·∫≠p t·ª©c m√† theo m·ªôt quy tr√¨nh b·∫•t ƒë·ªìng b·ªô (asynchronous) g·ªìm 3 b∆∞·ªõc.

**Model ƒë∆∞·ª£c h·ªó tr·ª£:** `veo 3` (Google Vertex AI)

## T·ªïng quan quy tr√¨nh

1.  **B·∫Øt ƒë·∫ßu t√°c v·ª•:** B·∫°n g·ª≠i m·ªôt y√™u c·∫ßu ch·ª©a m√¥ t·∫£ (prompt) ƒë·ªÉ b·∫Øt ƒë·∫ßu qu√° tr√¨nh t·∫°o video. API s·∫Ω tr·∫£ v·ªÅ m·ªôt `operation_name` ƒë·ªÉ b·∫°n theo d√µi.
2.  **Ki·ªÉm tra tr·∫°ng th√°i:** B·∫°n s·ª≠ d·ª•ng `operation_name` ƒë·ªÉ h·ªèi API xem video ƒë√£ ƒë∆∞·ª£c t·∫°o xong ch∆∞a. B·∫°n c·∫ßn l·∫∑p l·∫°i b∆∞·ªõc n√†y cho ƒë·∫øn khi nh·∫≠n ƒë∆∞·ª£c tr·∫°ng th√°i ho√†n t·∫•t.
3.  **T·∫£i video:** Khi video ƒë√£ s·∫µn s√†ng, k·∫øt qu·∫£ ki·ªÉm tra tr·∫°ng th√°i s·∫Ω ch·ª©a m·ªôt URI (ƒë∆∞·ªùng d·∫´n) ƒë·∫øn file video. B·∫°n s·ª≠ d·ª•ng URI n√†y ƒë·ªÉ t·∫£i video v·ªÅ.

## H∆∞·ªõng d·∫´n chi ti·∫øt

<Tabs>
  <TabItem value="curl" label="curl (T·ª´ng b∆∞·ªõc)">
    <h4>B∆∞·ªõc 1: B·∫Øt ƒë·∫ßu t·∫°o video</h4>
    <p>G·ª≠i m·ªôt y√™u c·∫ßu POST ƒë·∫øn endpoint ƒë·∫∑c bi·ªát d√†nh cho Veo.</p>
    <CodeBlock language="bash">
    {`curl -X POST https://api0.lab.vbi-server.com/models/veo-3.0-generate-preview:predictLongRunning \\
  -H "Content-Type: application/json" \\
  -H "Authorization: Bearer <your_api_key>" \\
  -d '{
    "instances": [{
      "prompt": "A cinematic shot of a hummingbird flying in slow motion"
    }]
  }'`}
    </CodeBlock>
    <p>N·∫øu th√†nh c√¥ng, API s·∫Ω tr·∫£ v·ªÅ m·ªôt JSON ch·ª©a <code>name</code> c·ªßa t√°c v·ª•. H√£y l∆∞u l·∫°i gi√° tr·ªã n√†y.</p>
    
    <h4>B∆∞·ªõc 2: Ki·ªÉm tra tr·∫°ng th√°i</h4>
    <p>S·ª≠ d·ª•ng <code>operation_name</code> b·∫°n nh·∫≠n ƒë∆∞·ª£c ·ªü B∆∞·ªõc 1 ƒë·ªÉ g·ª≠i y√™u c·∫ßu GET.</p>
    <CodeBlock language="bash">
    {`# Thay operations/1234567890 b·∫±ng operation_name c·ªßa b·∫°n
curl https://api0.lab.vbi-server.com/operations/1234567890 \\
  -H "Authorization: Bearer <your_api_key>"`}
    </CodeBlock>
    <p>L·∫∑p l·∫°i y√™u c·∫ßu n√†y cho ƒë·∫øn khi response ch·ª©a <code>"done": true</code>.</p>

    <h4>B∆∞·ªõc 3: T·∫£i video</h4>
    <p>S·ª≠ d·ª•ng <code>uri</code> t·ª´ response ·ªü B∆∞·ªõc 2 ƒë·ªÉ t·∫£i video.</p>
    <CodeBlock language="bash">
    {`# URI g·ªëc: https://generativelanguage.googleapis.com/v1beta/files/generated_video_abcxyz
# File path: v1beta/files/generated_video_abcxyz

curl https://api0.lab.vbi-server.com/download/v1beta/files/generated_video_abcxyz \\
  -H "Authorization: Bearer <your_api_key>" \\
  --output my_generated_video.mp4`}
    </CodeBlock>
  </TabItem>
  <TabItem value="python" label="Python (Script t·ª± ƒë·ªông)">
    <p>D∆∞·ªõi ƒë√¢y l√† m·ªôt k·ªãch b·∫£n Python ho√†n ch·ªânh ƒë·ªÉ t·ª± ƒë·ªông h√≥a c·∫£ 3 b∆∞·ªõc, s·ª≠ d·ª•ng code g·ªëc t·ª´ repository <code>ansible-litellm-proxy</code>.</p>
    <CodeBlock language="python">
    {`#!/usr/bin/env python3
"""
Complete example for Veo video generation through LiteLLM proxy.

This script demonstrates how to:
1. Generate videos using Google's Veo model
2. Poll for completion status
3. Download the generated video file

Requirements:
- LiteLLM proxy running with Google AI Studio pass-through configured
- Google AI Studio API key with Veo access

# This file is forked and adapted from: https://github.com/BerriAI/litellm/blob/main/docs/my-website/docs/proxy/veo_video_generation.md .Please refer to the original for license details.
"""

import json
import os
import time
import requests
from typing import Optional


class VeoVideoGenerator:
    """Complete Veo video generation client using VBI AI Gateway."""
    
    def __init__(self, base_url: str = "https://api0.lab.vbi-server.com", 
                 api_key: str = "YOUR_API_KEY"): # Thay b·∫±ng API key c·ªßa b·∫°n
        """
        Initialize the Veo video generator.
        
        Args:
            base_url: Base URL for the VBI AI Gateway
            api_key: Your API key for authentication
        """
        self.base_url = base_url
        self.api_key = api_key
        self.headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        }
    
    def generate_video(self, prompt: str) -> Optional[str]:
        """
        Initiate video generation with Veo.
        
        Args:
            prompt: Text description of the video to generate
            
        Returns:
            Operation name if successful, None otherwise
        """
        print(f"üé¨ Generating video with prompt: '{prompt}'")
        
        url = f"{self.base_url}/models/veo-3.0-generate-preview:predictLongRunning"
        payload = {
            "instances": [{
                "prompt": prompt
            }]
        }
        
        try:
            response = requests.post(url, headers=self.headers, json=payload)
            response.raise_for_status()
            
            data = response.json()
            operation_name = data.get("name")
            
            if operation_name:
                print(f"‚úÖ Video generation started: {operation_name}")
                return operation_name
            else:
                print("‚ùå No operation name returned")
                print(f"Response: {json.dumps(data, indent=2)}")
                return None
                
        except requests.RequestException as e:
            print(f"‚ùå Failed to start video generation: {e}")
            if hasattr(e, 'response') and e.response is not None:
                try:
                    error_data = e.response.json()
                    print(f"Error details: {json.dumps(error_data, indent=2)}")
                except:
                    print(f"Error response: {e.response.text}")
            return None
    
    def wait_for_completion(self, operation_name: str, max_wait_time: int = 600) -> Optional[str]:
        """
        Poll operation status until video generation is complete.
        
        Args:
            operation_name: Name of the operation to monitor
            max_wait_time: Maximum time to wait in seconds (default: 10 minutes)
            
        Returns:
            Video URI if successful, None otherwise
        """
        print("‚è≥ Waiting for video generation to complete...")
        
        operation_url = f"{self.base_url}/{operation_name}"
        start_time = time.time()
        poll_interval = 10  # Start with 10 seconds
        
        while time.time() - start_time < max_wait_time:
            try:
                print(f"üîç Polling status... ({int(time.time() - start_time)}s elapsed)")
                
                response = requests.get(operation_url, headers=self.headers)
                response.raise_for_status()
                
                data = response.json()
                
                if "error" in data:
                    print("‚ùå Error in video generation:")
                    print(json.dumps(data["error"], indent=2))
                    return None
                
                is_done = data.get("done", False)
                
                if is_done:
                    print("üéâ Video generation complete!")
                    
                    try:
                        video_url = data["response"]["generatedSamples"][0]["video"]["uri"]
                        print(f"üìπ Video URI: {video_url}")
                        return video_url
                    except KeyError as e:
                        print(f"‚ùå Could not extract video URI: {e}")
                        print("Full response:")
                        print(json.dumps(data, indent=2))
                        return None
                
                time.sleep(poll_interval)
                poll_interval = min(poll_interval * 1.2, 30)
                
            except requests.RequestException as e:
                print(f"‚ùå Error polling operation status: {e}")
                time.sleep(poll_interval)
        
        print(f"‚è∞ Timeout after {max_wait_time} seconds")
        return None
    
    def download_video(self, video_url: str, output_filename: str = "generated_video.mp4") -> bool:
        """
        Download the generated video file.
        
        Args:
            video_url: URI of the video to download
            output_filename: Local filename to save the video
            
        Returns:
            True if download successful, False otherwise
        """
        print(f"‚¨áÔ∏è  Downloading video...")
        
        if video_url.startswith("https://generativelanguage.googleapis.com/"):
            relative_path = video_url.replace("https://generativelanguage.googleapis.com/", "")
        else:
            relative_path = video_url

        litellm_download_url = f"{self.base_url}/download/{relative_path}"
        print(f"Download URL: {litellm_download_url}")
        
        try:
            response = requests.get(litellm_download_url, headers=self.headers, stream=True, allow_redirects=True)
            response.raise_for_status()
            
            with open(output_filename, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
            
            if os.path.exists(output_filename) and os.path.getsize(output_filename) > 0:
                print(f"‚úÖ Video downloaded successfully to {output_filename}")
                return True
            else:
                print("‚ùå Downloaded file is empty or was not created")
                return False
                
        except requests.RequestException as e:
            print(f"‚ùå Download failed: {e}")
            return False
    
    def generate_and_download(self, prompt: str, output_filename: str = None) -> bool:
        """
        Complete workflow: generate video and download it.
        """
        if output_filename is None:
            timestamp = int(time.time())
            safe_prompt = "".join(c for c in prompt[:30] if c.isalnum() or c in (' ', '-', '_')).rstrip()
            output_filename = f"veo_video_{safe_prompt.replace(' ', '_')}_{timestamp}.mp4"
        
        operation_name = self.generate_video(prompt)
        if not operation_name:
            return False
        
        video_url = self.wait_for_completion(operation_name)
        if not video_url:
            return False
        
        return self.download_video(video_url, output_filename)


def main():
    """
    Example usage of the VeoVideoGenerator.
    """
    base_url = os.getenv("VBI_API_BASE", "https://api0.lab.vbi-server.com")
    api_key = os.getenv("VBI_API_KEY", "sk-1234") # Thay b·∫±ng API key c·ªßa b·∫°n
    
    generator = VeoVideoGenerator(base_url=base_url, api_key=api_key)
    
    prompt = "A cat playing with a ball of yarn in a sunny garden"
    generator.generate_and_download(prompt)


if __name__ == "__main__":
    main()`}
    </CodeBlock>
  </TabItem>
</Tabs>
